use int.Int
use list.ListRich

type token = INT | LPAREN | RPAREN | PLUS

inductive pe (e : list token) =
    | Plus : forall e1 e2. pe e1 -> pe e2 -> pe (e1 ++ Cons PLUS e2)
    | Paren : forall e. pe e -> pe (Cons LPAREN (e ++ (Cons RPAREN Nil)))
    | Int : pe (Cons INT Nil)

goal pe1 : pe (Cons INT Nil)
goal pe2 : pe (Cons INT (Cons PLUS (Cons INT (Cons PLUS (Cons INT Nil)))))

inductive pe' (e : list token) =
    | Plus' : forall e1 e2. pe' e1 -> pt e2 -> pe' (e1 ++ Cons PLUS e2)
    | T' : forall t. pt t -> pe' t

with pt (e : list token) =
    | Paren' : forall e. pe' e -> pt (Cons LPAREN (e ++ (Cons RPAREN Nil)))
    | Int' : pt (Cons INT Nil)

goal pep1 : pe' (Cons INT Nil)
goal pep2 : pe' (Cons INT (Cons PLUS (Cons INT (Cons PLUS (Cons INT Nil)))))

let rec lemma di_str (n : int) (e : list token)
    variant { n }
    requires { (length e <= n /\ pt e) \/ (length e < n /\ pe' e) }
    ensures { pe e }
    =
    ()

let lemma disambiguation_included (e : list token)
    requires { pe' e }
    ensures { pe e }
    =
    di_str (length e + 1) e

predicate plus (e : list token) =
	  exists e1 e2. pe e1 /\ pe e2 /\ e = e1 ++ Cons PLUS e2

(*let decomp (acc : list token) (e : list token) : (e1 : list token, e2 : list token)
   requires { pe acc }
   requires { pe e }
   ensures { pe e1 }
   ensures { pe e2 /\ not plus e2 }
   ensures { acc ++ Cons PLUS e = e1 ++ Cons PLUS e2 }
   =
   (acc, e)
*)

lemma elp_str :
      forall n. forall e. length e <= n -> plus e ->
      exists e1 e2. e = e1 ++ Cons PLUS e2 /\ pe e1 /\ pe e2 /\ not plus e2

lemma e_last_plus :
      forall e. plus e ->
      exists e1 e2. e = e1 ++ Cons PLUS e2 /\ pe e1 /\ pe e2 /\ not plus e2

lemma oi_str :
      forall n. forall e. length e <= n -> pe e -> pe' e

lemma original_included :
      forall e. pe e -> pe' e

lemma equiv_disambiguation :
	forall e. pe e <-> pe' e
